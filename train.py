# -*- coding: utf-8 -*-
"""train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oD3BdMBhY0QvjCCSB64m1uKHChlga9GJ

```
# Isto está formatado como código
```

## Models Results Análisis
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
import seaborn as sns
import pickle

from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

from sklearn.ensemble import GradientBoostingRegressor

"""##Full Training"""

#Load DataFrame
df = pd.read_csv("Datasets/BCP_extended_dataframe.csv")

#Testing DataFrames
dfX = df.iloc[:,1:-2]
dfy = df.iloc[:,-2:]
dfX_fulltrain, dfX_test, dfy_fulltrain, dfy_test  = train_test_split(dfX, dfy, test_size=0.2, random_state= 4)
dfX_fulltrain = dfX_fulltrain.reset_index(drop = True)
dfX_test = dfX_test.reset_index(drop = True)
dfy_fulltrain = dfy_fulltrain.reset_index(drop = True)
dfy_test = dfy_test.reset_index(drop = True)

def regressor_gb_trainer(X_train, y_train, max_depth, min_samples_leaf, n_estimators=50):
    gb_regressor = GradientBoostingRegressor(n_estimators=n_estimators, learning_rate=0.1, max_depth=max_depth, min_samples_leaf=min_samples_leaf, random_state=42)
    gb_regressor.fit(X_train, y_train)
    return gb_regressor

def model_evaluator(dfy_eval, y_eval_pred, result_indentificator_string, aceptable_error=3):
  if result_indentificator_string == "next_week_value":
    individual_errors = (dfy_eval[result_indentificator_string] - y_eval_pred[:,1])/dfy_eval[result_indentificator_string]*100
  elif result_indentificator_string == "next_day_value":
    individual_errors = (dfy_eval[result_indentificator_string] - y_eval_pred[:,0])/dfy_eval[result_indentificator_string]*100
  elif result_indentificator_string == "one_value":
    individual_errors = (dfy_eval - y_eval_pred)/dfy_eval*100
  else:
    raise ValueError("Please enter a valid value for the argument result_indentificator_string")
  acceptabe_predictins_7d = (np.abs(individual_errors)<=aceptable_error).sum()
  moderate_unacceptable_predictins_7d=(np.abs(individual_errors)>aceptable_error).sum() - (np.abs(individual_errors)>(aceptable_error*5/3)).sum()
  highly_unacceptable_predictions_7d=(np.abs(individual_errors)>=(aceptable_error*5/3)).sum() - (np.abs(individual_errors)>20).sum()
  blatant_unacceptable_predictions_7d = (np.abs(individual_errors)>20).sum()
  total_unacceptable_predictions = (np.abs(individual_errors)>aceptable_error).sum()
  acceptable_ratio = acceptabe_predictins_7d/(total_unacceptable_predictions+acceptabe_predictins_7d)
  acceptable_ratio = np.round(acceptable_ratio,2)
  acceptable_weighted_ratio = acceptabe_predictins_7d/(moderate_unacceptable_predictins_7d+(highly_unacceptable_predictions_7d*2)+(blatant_unacceptable_predictions_7d*4)+acceptabe_predictins_7d)
  acceptable_weighted_ratio = np.round(acceptable_weighted_ratio,2)
  #print(f"The Acceptable Ratio (accuracy) is {acceptable_ratio}")
  #print(f"the Weighted Ratio is {acceptable_weighted_ratio}")
  return individual_errors, acceptable_ratio, acceptable_weighted_ratio

max_depth = 15
min_samples_leaf = 1
n_estimators = 400
result_columns = ["n_estimators", "max_depth", "min_samples_leaf","rsme", "acceptable_ratio_1d", "acceptable_weighted_ratio_1d", "acceptable_ratio_7d", "acceptable_weighted_ratio_7d" ]
results = pd.DataFrame(columns=result_columns)

y_fulltrain_1d = dfy_fulltrain['next_day_value']
model_1d = regressor_gb_trainer(dfX_fulltrain, y_fulltrain_1d, max_depth, min_samples_leaf, n_estimators=200)
y_test_pred_1d = model_1d.predict(dfX_test)
rsme_1d = mean_squared_error(dfy_test["next_day_value"], y_test_pred_1d, squared=False)
errors_1d, acceptable_ratio_1d, acceptable_weighted_ratio_1d = model_evaluator(dfy_test["next_day_value"], y_test_pred_1d, "one_value", aceptable_error=1.5)
print (f"For a max_depth of {max_depth} and a min_samples_leaf of {min_samples_leaf}, the 1 Day Prediction Ratios are:")
print (f"acceptable_ratio_1d: {acceptable_ratio_1d} ")
print (f"acceptable_weighted_ratio_1d: {acceptable_weighted_ratio_1d} ")


y_fulltrain_7d = dfy_fulltrain['next_week_value']
model_7d = regressor_gb_trainer(dfX_fulltrain, y_fulltrain_7d, max_depth, min_samples_leaf, n_estimators=200)
y_test_pred_7d = model_7d.predict(dfX_test)
rsme_7d = mean_squared_error(dfy_test["next_week_value"], y_test_pred_7d, squared=False)
errors_7d, acceptable_ratio_7d, acceptable_weighted_ratio_7d = model_evaluator(dfy_test["next_week_value"], y_test_pred_7d, "one_value", aceptable_error=3)
print (f"For a max_depth of {max_depth} and a min_samples_leaf of {min_samples_leaf}, the 7 Day Prediction Ratios are:")
print (f"acceptable_ratio_7d: {acceptable_ratio_7d} ")
print (f"acceptable_weighted_ratio_7d: {acceptable_weighted_ratio_7d} ")

rsme = (rsme_1d + errors_7d)/2

new_row = [n_estimators, max_depth , min_samples_leaf, rsme, acceptable_ratio_1d, acceptable_weighted_ratio_1d, acceptable_ratio_7d, acceptable_weighted_ratio_7d]
new_row_df = pd.DataFrame([new_row], columns=results.columns)

results = pd.concat([results, new_row_df], ignore_index=True)

output_file = 'model_selected'
with open(output_file+"_1d.bin", 'wb') as f_out:
    pickle.dump(model_1d, f_out)

print(f'the model for 1 day prediction is saved to {output_file+"_1d.bin"}')

with open(output_file+"_7d.bin", 'wb') as f_out:
    pickle.dump(model_7d, f_out)

print(f'the model for 7 day prediction is saved to {output_file+"_7d.bin"}')